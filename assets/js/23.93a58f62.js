(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{291:function(t,r,a){"use strict";a.r(r);var e=a(1),o=Object(e.a)({},function(){var t=this,r=t.$createElement,a=t._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("本讲主要说明Quartz中存储机制。")]),t._v(" "),a("h2",{attrs:{id:"job-stores"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#job-stores","aria-hidden":"true"}},[t._v("#")]),t._v(" Job Stores")]),t._v(" "),a("h3",{attrs:{id:"ramjobstore"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ramjobstore","aria-hidden":"true"}},[t._v("#")]),t._v(" RAMJobStore")]),t._v(" "),a("p",[t._v("RAMJobStore是使用最简单的JobStore，它也是性能最高的（在CPU时间方面）。RAMJobStore以其明显的方式获取其名称：它将其所有数据保存在RAM中。这就是为什么它是闪电般快的，也是为什么这么简单的配置。缺点是当您的应用程序结束（或崩溃）时，所有调度信息都将丢失 - 这意味着RAMJobStore无法履行作业和triggers上的“非易失性”设置。对于某些应用程序，这是可以接受的 - 甚至是所需的行为，但对于其他应用程序，这可能是灾难性的。")]),t._v(" "),a("p",[t._v("配置Quartz以使用RAMJobStore")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[t._v("org"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("quartz"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("jobStore"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" org"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("quartz"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("simpl"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("RAMJobStore")]),t._v("\n")])])]),a("h3",{attrs:{id:"jdbc-jobstore"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jdbc-jobstore","aria-hidden":"true"}},[t._v("#")]),t._v(" JDBC JobStore")]),t._v(" "),a("p",[t._v("JDBCJobStore也被恰当地命名 - 它通过JDBC将其所有数据保存在数据库中。因此，配置比RAMJobStore要复杂一点，而且也不是那么快。但是，性能下降并不是很糟糕，特别是如果您在主键上构建具有索引的数据库表。在相当现代的一套具有体面的LAN（在调度程序和数据库之间）的机器上，检索和更新触发triggers的时间通常将小于10毫秒。")]),t._v(" "),a("p",[t._v("要使用JDBCJobStore，必须首先创建一组数据库表以供Quartz使用。您可以在Quartz发行版的“docs / dbTables”目录中找到表创建SQL脚本。如果您的数据库类型尚未有脚本，请查看其中一个脚本，然后以数据库所需的任何方式进行修改。需要注意的一点是，在这些脚本中，所有的表都以前缀“QRTZ_”开始（如表“QRTZ_TRIGGERS”和“QRTZ_JOB_DETAIL”）。只要你通知JDBCJobStore前缀是什么（在你的Quartz属性中），这个前缀实际上可以是你想要的。\n配置信息：")]),t._v(" "),a("div",{staticClass:"language-xml extra-class"},[a("pre",{pre:!0,attrs:{class:"language-xml"}},[a("code",[t._v("org.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreTX\norg.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.StdJDBCDelegate\n# 配置表前缀\norg.quartz.jobStore.tablePrefix = QRTZ_\n# 配置DataSource\norg.quartz.jobStore.dataSource = myDS\n")])])]),a("p",[t._v("好了，Quartz大致的基础知识到这里就差不多完了，如果你想了解更多更新更全的配置信息，请到W3Cschool学习吧！（PS:是目前我看到整理Quartz最优质的文档）\n"),a("a",{attrs:{href:"https://www.w3cschool.cn/quartz_doc/",target:"_blank",rel:"noopener noreferrer"}},[t._v("w3cschool《Quarzt官方文档》"),a("OutboundLink")],1)])])},[],!1,null,null,null);r.default=o.exports}}]);